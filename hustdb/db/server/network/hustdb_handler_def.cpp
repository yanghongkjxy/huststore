////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by libevhtp.py. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "hustdb_handler_def.h"

hustdb_exist_ctx_t::hustdb_exist_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_get_ctx_t::hustdb_get_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_put_ctx_t::hustdb_put_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;
    has_val = false;
    has_ttl = false;
    has_ver = false;
    has_is_dup = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));
    ttl = 0;
    ver = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_del_ctx_t::hustdb_del_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;
    has_ver = false;
    has_is_dup = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));
    ver = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_keys_ctx_t::hustdb_keys_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_offset = false;
    has_size = false;
    has_file = false;
    has_start = false;
    has_end = false;
    has_noval = false;
    has_async = false;

    offset = -1;
    size = -1;
    file = -1;
    start = 0;
    end = MAX_BUCKET_NUM;
    noval = true;
    async = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __offset = evhtp_make_str("offset");
        static evhtp::c_str_t __size = evhtp_make_str("size");
        static evhtp::c_str_t __file = evhtp_make_str("file");
        static evhtp::c_str_t __start = evhtp_make_str("start");
        static evhtp::c_str_t __end = evhtp_make_str("end");
        static evhtp::c_str_t __noval = evhtp_make_str("noval");
        static evhtp::c_str_t __async = evhtp_make_str("async");

        if (kv->klen == __offset.len && 0 == strncmp(__offset.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_offset = true;
            offset = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __size.len && 0 == strncmp(__size.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_size = true;
            size = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __file.len && 0 == strncmp(__file.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_file = true;
            file = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __start.len && 0 == strncmp(__start.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_start = true;
            start = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __end.len && 0 == strncmp(__end.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_end = true;
            end = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __noval.len && 0 == strncmp(__noval.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_noval = true;
            noval = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        else if (kv->klen == __async.len && 0 == strncmp(__async.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_async = true;
            async = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_stat_ctx_t::hustdb_stat_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_hexist_ctx_t::hustdb_hexist_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_hget_ctx_t::hustdb_hget_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_hset_ctx_t::hustdb_hset_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_val = false;
    has_ttl = false;
    has_ver = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));
    ttl = 0;
    ver = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_hincrby_ctx_t::hustdb_hincrby_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_val = false;
    has_ttl = false;
    has_ver = false;
    has_host = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(int64_t));
    ttl = 0;
    ver = 0;
    memset(&host, 0, sizeof(evhtp::c_str_t));
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __host = evhtp_make_str("host");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val = evhtp::cast <int64_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __host.len && 0 == strncmp(__host.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_host = true;
            host.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_hdel_ctx_t::hustdb_hdel_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_ver = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    ver = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_hkeys_ctx_t::hustdb_hkeys_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_offset = false;
    has_size = false;
    has_start = false;
    has_end = false;
    has_noval = false;
    has_async = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    offset = -1;
    size = -1;
    start = 0;
    end = MAX_BUCKET_NUM;
    noval = true;
    async = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __offset = evhtp_make_str("offset");
        static evhtp::c_str_t __size = evhtp_make_str("size");
        static evhtp::c_str_t __start = evhtp_make_str("start");
        static evhtp::c_str_t __end = evhtp_make_str("end");
        static evhtp::c_str_t __noval = evhtp_make_str("noval");
        static evhtp::c_str_t __async = evhtp_make_str("async");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __offset.len && 0 == strncmp(__offset.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_offset = true;
            offset = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __size.len && 0 == strncmp(__size.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_size = true;
            size = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __start.len && 0 == strncmp(__start.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_start = true;
            start = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __end.len && 0 == strncmp(__end.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_end = true;
            end = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __noval.len && 0 == strncmp(__noval.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_noval = true;
            noval = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        else if (kv->klen == __async.len && 0 == strncmp(__async.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_async = true;
            async = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_sismember_ctx_t::hustdb_sismember_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_sadd_ctx_t::hustdb_sadd_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_ver = false;
    has_ttl = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    ver = 0;
    ttl = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_srem_ctx_t::hustdb_srem_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_ver = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    ver = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_smembers_ctx_t::hustdb_smembers_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_offset = false;
    has_size = false;
    has_start = false;
    has_end = false;
    has_noval = false;
    has_async = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    offset = -1;
    size = -1;
    start = 0;
    end = MAX_BUCKET_NUM;
    noval = true;
    async = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __offset = evhtp_make_str("offset");
        static evhtp::c_str_t __size = evhtp_make_str("size");
        static evhtp::c_str_t __start = evhtp_make_str("start");
        static evhtp::c_str_t __end = evhtp_make_str("end");
        static evhtp::c_str_t __noval = evhtp_make_str("noval");
        static evhtp::c_str_t __async = evhtp_make_str("async");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __offset.len && 0 == strncmp(__offset.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_offset = true;
            offset = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __size.len && 0 == strncmp(__size.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_size = true;
            size = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __start.len && 0 == strncmp(__start.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_start = true;
            start = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __end.len && 0 == strncmp(__end.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_end = true;
            end = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __noval.len && 0 == strncmp(__noval.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_noval = true;
            noval = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        else if (kv->klen == __async.len && 0 == strncmp(__async.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_async = true;
            async = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_export_ctx_t::hustdb_export_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_file = false;
    has_start = false;
    has_end = false;
    has_offset = false;
    has_size = false;
    has_noval = false;
    has_cover = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    file = -1;
    start = 0;
    end = MAX_BUCKET_NUM;
    offset = 0;
    size = 0;
    noval = true;
    cover = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __file = evhtp_make_str("file");
        static evhtp::c_str_t __start = evhtp_make_str("start");
        static evhtp::c_str_t __end = evhtp_make_str("end");
        static evhtp::c_str_t __offset = evhtp_make_str("offset");
        static evhtp::c_str_t __size = evhtp_make_str("size");
        static evhtp::c_str_t __noval = evhtp_make_str("noval");
        static evhtp::c_str_t __cover = evhtp_make_str("cover");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __file.len && 0 == strncmp(__file.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_file = true;
            file = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __start.len && 0 == strncmp(__start.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_start = true;
            start = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __end.len && 0 == strncmp(__end.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_end = true;
            end = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __offset.len && 0 == strncmp(__offset.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_offset = true;
            offset = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __size.len && 0 == strncmp(__size.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_size = true;
            size = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __noval.len && 0 == strncmp(__noval.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_noval = true;
            noval = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        else if (kv->klen == __cover.len && 0 == strncmp(__cover.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_cover = true;
            cover = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_binlog_ctx_t::hustdb_binlog_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_host = false;
    has_method = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&host, 0, sizeof(evhtp::c_str_t));
    memset(&method, 0, sizeof(uint32_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __host = evhtp_make_str("host");
        static evhtp::c_str_t __method = evhtp_make_str("method");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __host.len && 0 == strncmp(__host.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_host = true;
            host.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __method.len && 0 == strncmp(__method.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_method = true;
            method = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_put_ctx_t::hustmq_put_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_item = false;
    has_priori = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    memset(&item, 0, sizeof(evhtp::c_str_t));
    priori = 0;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __item = evhtp_make_str("item");
        static evhtp::c_str_t __priori = evhtp_make_str("priori");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __item.len && 0 == strncmp(__item.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_item = true;
            item.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __priori.len && 0 == strncmp(__priori.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_priori = true;
            priori = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_get_ctx_t::hustmq_get_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_worker = false;
    has_ack = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    memset(&worker, 0, sizeof(evhtp::c_str_t));
    ack = true;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __worker = evhtp_make_str("worker");
        static evhtp::c_str_t __ack = evhtp_make_str("ack");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __worker.len && 0 == strncmp(__worker.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_worker = true;
            worker.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ack.len && 0 == strncmp(__ack.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ack = true;
            ack = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_ack_ctx_t::hustmq_ack_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_token = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    memset(&token, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __token = evhtp_make_str("token");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __token.len && 0 == strncmp(__token.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_token = true;
            token.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_timeout_ctx_t::hustmq_timeout_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_minute = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    memset(&minute, 0, sizeof(uint32_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __minute = evhtp_make_str("minute");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __minute.len && 0 == strncmp(__minute.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_minute = true;
            minute = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_worker_ctx_t::hustmq_worker_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_stat_ctx_t::hustmq_stat_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_max_ctx_t::hustmq_max_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_num = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    num = 0;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __num = evhtp_make_str("num");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __num.len && 0 == strncmp(__num.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_num = true;
            num = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_lock_ctx_t::hustmq_lock_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_on = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    on = 0;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __on = evhtp_make_str("on");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __on.len && 0 == strncmp(__on.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_on = true;
            on = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_purge_ctx_t::hustmq_purge_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_priori = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    priori = -1;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __priori = evhtp_make_str("priori");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __priori.len && 0 == strncmp(__priori.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_priori = true;
            priori = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_pub_ctx_t::hustmq_pub_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_item = false;
    has_idx = false;
    has_ttl = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    memset(&item, 0, sizeof(evhtp::c_str_t));
    idx = CYCLE_QUEUE_ITEM_NUM;
    ttl = DEF_MSG_TTL;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __item = evhtp_make_str("item");
        static evhtp::c_str_t __idx = evhtp_make_str("idx");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __item.len && 0 == strncmp(__item.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_item = true;
            item.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __idx.len && 0 == strncmp(__idx.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_idx = true;
            idx = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustmq_sub_ctx_t::hustmq_sub_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_queue = false;
    has_idx = false;

    memset(&queue, 0, sizeof(evhtp::c_str_t));
    idx = CYCLE_QUEUE_ITEM_NUM;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __queue = evhtp_make_str("queue");
        static evhtp::c_str_t __idx = evhtp_make_str("idx");

        if (kv->klen == __queue.len && 0 == strncmp(__queue.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_queue = true;
            queue.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __idx.len && 0 == strncmp(__idx.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_idx = true;
            idx = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_task_status_ctx_t::hustdb_task_status_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_token = false;

    memset(&token, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __token = evhtp_make_str("token");

        if (kv->klen == __token.len && 0 == strncmp(__token.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_token = true;
            token.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_zismember_ctx_t::hustdb_zismember_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_zscore_ctx_t::hustdb_zscore_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_zadd_ctx_t::hustdb_zadd_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_score = false;
    has_opt = false;
    has_key = false;
    has_ver = false;
    has_ttl = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    score = 0;
    opt = 0;
    memset(&key, 0, sizeof(evhtp::c_str_t));
    ver = 0;
    ttl = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __score = evhtp_make_str("score");
        static evhtp::c_str_t __opt = evhtp_make_str("opt");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __score.len && 0 == strncmp(__score.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_score = true;
            score = evhtp::cast <int64_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __opt.len && 0 == strncmp(__opt.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_opt = true;
            opt = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_zrem_ctx_t::hustdb_zrem_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_ver = false;
    has_is_dup = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    ver = 0;
    is_dup = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ver = evhtp_make_str("ver");
        static evhtp::c_str_t __is_dup = evhtp_make_str("is_dup");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ver.len && 0 == strncmp(__ver.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ver = true;
            ver = evhtp::cast <uint32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __is_dup.len && 0 == strncmp(__is_dup.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_is_dup = true;
            is_dup = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_zrangebyrank_ctx_t::hustdb_zrangebyrank_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_offset = false;
    has_size = false;
    has_start = false;
    has_end = false;
    has_noval = false;
    has_async = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    offset = -1;
    size = -1;
    start = 0;
    end = MAX_BUCKET_NUM;
    noval = true;
    async = false;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __offset = evhtp_make_str("offset");
        static evhtp::c_str_t __size = evhtp_make_str("size");
        static evhtp::c_str_t __start = evhtp_make_str("start");
        static evhtp::c_str_t __end = evhtp_make_str("end");
        static evhtp::c_str_t __noval = evhtp_make_str("noval");
        static evhtp::c_str_t __async = evhtp_make_str("async");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __offset.len && 0 == strncmp(__offset.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_offset = true;
            offset = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __size.len && 0 == strncmp(__size.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_size = true;
            size = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __start.len && 0 == strncmp(__start.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_start = true;
            start = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __end.len && 0 == strncmp(__end.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_end = true;
            end = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __noval.len && 0 == strncmp(__noval.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_noval = true;
            noval = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        else if (kv->klen == __async.len && 0 == strncmp(__async.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_async = true;
            async = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustdb_zrangebyscore_ctx_t::hustdb_zrangebyscore_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_min = false;
    has_max = false;
    has_offset = false;
    has_size = false;
    has_start = false;
    has_end = false;
    has_noval = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    min = 0;
    max = 0;
    offset = -1;
    size = -1;
    start = 0;
    end = MAX_BUCKET_NUM;
    noval = true;

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __min = evhtp_make_str("min");
        static evhtp::c_str_t __max = evhtp_make_str("max");
        static evhtp::c_str_t __offset = evhtp_make_str("offset");
        static evhtp::c_str_t __size = evhtp_make_str("size");
        static evhtp::c_str_t __start = evhtp_make_str("start");
        static evhtp::c_str_t __end = evhtp_make_str("end");
        static evhtp::c_str_t __noval = evhtp_make_str("noval");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __min.len && 0 == strncmp(__min.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_min = true;
            min = evhtp::cast <int64_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __max.len && 0 == strncmp(__max.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_max = true;
            max = evhtp::cast <int64_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __offset.len && 0 == strncmp(__offset.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_offset = true;
            offset = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __size.len && 0 == strncmp(__size.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_size = true;
            size = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __start.len && 0 == strncmp(__start.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_start = true;
            start = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __end.len && 0 == strncmp(__end.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_end = true;
            end = evhtp::cast <int32_t> (std::string(kv->val, kv->vlen));
        }
        else if (kv->klen == __noval.len && 0 == strncmp(__noval.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_noval = true;
            noval = (4 == kv->vlen && 0 == strncmp(kv->val, "true", 4)) ||
                (1 == kv->vlen && 0 == strncmp(kv->val, "1", 1));
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_exist_ctx_t::hustcache_exist_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_get_ctx_t::hustcache_get_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_ttl_ctx_t::hustcache_ttl_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_put_ctx_t::hustcache_put_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;
    has_val = false;
    has_ttl = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));
    memset(&ttl, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_append_ctx_t::hustcache_append_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;
    has_val = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_del_ctx_t::hustcache_del_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_expire_ctx_t::hustcache_expire_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;
    has_ttl = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&ttl, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __ttl = evhtp_make_str("ttl");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __ttl.len && 0 == strncmp(__ttl.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_ttl = true;
            ttl.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_persist_ctx_t::hustcache_persist_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_key = false;

    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_hexist_ctx_t::hustcache_hexist_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_hget_ctx_t::hustcache_hget_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_hset_ctx_t::hustcache_hset_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_val = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_hdel_ctx_t::hustcache_hdel_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_hincrby_ctx_t::hustcache_hincrby_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_val = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}

hustcache_hincrbyfloat_ctx_t::hustcache_hincrbyfloat_ctx_t(evhtp_query_t * htp_query)
{
    // reset
    has_tb = false;
    has_key = false;
    has_val = false;

    memset(&tb, 0, sizeof(evhtp::c_str_t));
    memset(&key, 0, sizeof(evhtp::c_str_t));
    memset(&val, 0, sizeof(evhtp::c_str_t));

    if (!htp_query)
    {
        return;
    }
    // parse from htp_query
    evhtp_kv_s * kv = htp_query->tqh_first;
    while (kv)
    {
        static evhtp::c_str_t __tb = evhtp_make_str("tb");
        static evhtp::c_str_t __key = evhtp_make_str("key");
        static evhtp::c_str_t __val = evhtp_make_str("val");

        if (kv->klen == __tb.len && 0 == strncmp(__tb.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_tb = true;
            tb.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __key.len && 0 == strncmp(__key.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_key = true;
            key.assign(kv->val, kv->vlen);
        }
        else if (kv->klen == __val.len && 0 == strncmp(__val.data, kv->key, kv->klen) && kv->val && kv->vlen > 0)
        {
            has_val = true;
            val.assign(kv->val, kv->vlen);
        }
        kv = kv->next.tqe_next;
    }
}
